var fs = require('fs'),
    exec = require('child_process').exec, child;

function bmp_info(data){
  
  //Read BMP header to find beginning of pixel array, etc
  var info = {
    pixel_start: data.readUInt32LE(0xA),
    img_w: data.readInt32LE(0x12),
    img_h: data.readInt32LE(0x16),
    bit_depth: data.readUInt16LE(0x1C),
    size: data.readUInt32LE(0x02),
    //encode puts length of nibble array in header here, this reads it
    stego_size: data.readUInt32LE(0x06)
  };

  //calculated BMP info
  info.pixelArray_length = data.length - info.pixel_start;

  //pad row_size if needed, must be a multiple of a 32-bit DWORD
  if((info.img_w*3) % 4 != 0){
    info.row_padding = (Math.ceil(info.img_w*3/4)*4)-info.img_w*3;
  } else {
    info.row_padding = 0;
  }
  return info;
}


function encode(secret, image_file, callback){
  //Convert image file to bmp with image magick 'convert'
  child = exec('convert '+image_file+' '+image_file+'.bmp',['-depth','24'], function(err, stdout, stderr){
    if(err) throw err;
    image_file = image_file+'.bmp';

    //read our secret file
    fs.readFile(secret, function(err, secret_data){
      if(err) throw err;
        //read our image file
        fs.readFile(image_file, function(err, data){
          if(err) throw err;
          var bmp = bmp_info(data),
              skip = 0,
              nib_secret= [];
          console.log(bmp);
          
          //Checks to see if secret will fit in the pixel array
          if(secret_data.length >= bmp.pixelArray_length/6){
            callback('Secret file is <strong>'+ (secret_data.length/1024).toFixed(2)+
            'kB</strong>, it needs to be <strong>&lt;'+
            (bmp.pixelArray_length/6144).toFixed(2)+'kB</strong> to fit in your image', 'none');
            return;
          }

          //this loop nibbles our bytes [11110000] -> [1111][0000]
          for(var i=0; i< secret_data.length; i++){
            nib_secret.push(secret_data[i] & 0xF);
            nib_secret.push(secret_data[i] >> 4);
          }
          //write length of nibbled stego data to header of image buffer
          data.writeUInt32LE(nib_secret.length, 0x06);

          //loop through image data and do magic
          for(var i=0; i< nib_secret.length; i++){

            if(i != 0 && bmp.row_padding != 0 && i*3 % (bmp.img_w) == 0){
              //skip padding to keep alignment
              skip += bmp.row_padding;
            }
            //calculate byte position
            var byte_pos = bmp.pixel_start+(i*3)+skip;

            stego_val = (data[byte_pos] & 0xF0 ) | nib_secret[i];
            data[byte_pos] = stego_val;
          }
          var d = new Date();
          var file_name = d.getTime()+'.bmp';
          var output = './public/images/'+file_name;
          fs.writeFile(output, data, function(err){
            if(err) throw err;
            if(typeof(callback) === 'function'){
              callback('Success!', file_name);
            }
          });
        });
    });
  });
}

function decode(offset, stego_path, callback){
  fs.readFile(stego_path, function(err, data){
    if(err) throw err;
    var bmp = bmp_info(data),
        skip = 0,
        off = 0,
        nib_array = [],
        decode = [];

    for(var i=0; i<bmp.stego_size; i++){
      if(i != 0 && bmp.row_padding != 0 && i*3 % (bmp.img_w) == 0){
        //skip padding to keep alignment
        skip+= bmp.row_padding;
      }
      //calculate byte position
      var byte_pos = bmp.pixel_start+(i*3)+skip;
      nib_array.push(data[byte_pos] & 0xF);
    }

    //re-assemble original bytes from extrated nibbles
    for(var i=0; i<nib_array.length; i=i+2){
      decode.push(nib_array[i]|(nib_array[i+1]<<4));
    }

    //put decoded array into a buffer
    message = new Buffer(decode);
    var d = new Date();
    var file_name = 'decode_'+d.getTime();

    fs.writeFile('./public/data/'+file_name, message, function(err){
      if(err) throw err;
      if(typeof(callback) === 'function'){
        callback(file_name, message.length);
      }
    });
 });
}

exports.decode = decode;
exports.encode = encode;
